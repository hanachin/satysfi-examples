@require: list
@require: option
@require: hanachin/str

module Regexp : sig
  type token
  type node
  type bytecode
  val lex : string -> token list
  val parse : token list -> node
  val compile : node -> bytecode list
  val exec : bytecode list -> string -> ((int * string) list) option
  val from : string -> (string -> ((int * string) list) option)
end = struct
  type token =
    | T-char of string
    | T-dot
    | T-lparen
    | T-rparen

  type node =
    | N-cat of node * node
    | N-dot
    | N-empty
    | N-lit of string
    | N-ng-star of node
    | N-paren of int * node
    | N-parse-failed

  type bytecode =
    | O-any
    | O-char of string
    | O-jump of int
    | O-match
    | O-not-match
    | O-split of int * int
    | O-subend of int
    | O-substart of int

  let lex s =
    let-rec inner
      | [] = []
      | (`(` :: cs) = T-lparen :: inner cs
      | (`)` :: cs) = T-rparen :: inner cs
      | (`.` :: cs) = T-dot :: inner cs
      | (c :: cs) = T-char(c) :: inner cs
    in
    inner (split-into-chars s)

  let parse2 tokens =
    let choice fns =
      let-rec inner
        | [] tn tokens = None
        | (fn :: fns) tn tokens = (
          match !fn tn tokens with
          | Some(tn, ret) -> Some(tn, ret)
          | None -> inner fns tn tokens
        )
      in

      fun tn tokens -> inner fns tn tokens
    in

    let many fn =
      let-rec inner
        | fn a tn tokens = (
          match !fn tn tokens with
          | Some(tn, ret) -> inner fn (List.concat [a; [ret]]) tn tokens
          | None -> (tn, a)
        )
      in
      fun tn tokens -> inner fn [] tn tokens
    in

    let seq fns =
      let-rec inner
      | [] a tn tokens = Some(tn, a)
      | (fn :: fns) a tn tokens = (
        match !fn tn tokens with
        | Some(tn, ret) -> inner fns (List.concat [a; [ret]]) tn tokens
        | None -> None
      )
      in
      fun tn tokens -> inner fns [] tn tokens
    in

    let default = (fun tn tokens -> None) in
    let-mutable n <- 0 in
    let-mutable cat <- default in
    let-mutable char <- default in
    let-mutable dot <- default in
    let-mutable lparen <- default in
    let-mutable rparen <- default in
    let-mutable paren <- default in
    let-mutable single <- default in

    let () = cat <- (fun tn tokens -> (
      match (many single) tn tokens with
      | (tn, (head :: ns)) -> Some(tn, ns |> (List.fold-left (fun a n -> N-cat(a, n)) head))
      | (tn, []) -> None
    ))
    in

    let () = char <- (fun tn tokens -> (
      match List.nth tn tokens with
      | Some(T-char(c)) -> Some(tn + 1, N-lit(c))
      | _ -> None
    ))
    in

    let () = dot <- (fun tn tokens -> (
      match List.nth tn tokens with
      | Some(T-dot) -> Some(tn + 1, N-dot)
      | _ -> None
    ))
    in

    let () = lparen <- (fun tn tokens -> (
      match List.nth tn tokens with
      | Some(T-lparen) -> Some(tn + 1, N-empty)
      | _ -> None
    ))
    in

    let () = rparen <- (fun tn tokens -> (
      match List.nth tn tokens with
      | Some(T-rparen) -> Some(tn + 1, N-empty)
      | _ -> None
    ))
    in

    let () = paren <- (fun tn tokens -> (
      match (seq [lparen; cat; rparen]) tn tokens with
      | Some(tn, (head :: ns)) -> (
        let () = n <- !n + 1 in
        let t = ns |> (List.fold-left (fun a n -> N-cat(a, n)) head) in
        Some(tn, N-paren(!n, t))
      )
      | _ -> None
    ))
    in

    let () = single <- choice [paren; char; dot] in

    match !cat 0 tokens with
    | Some(tn, root) -> (
      if tn == (List.length tokens) then
        N-cat(N-ng-star(N-dot), N-paren(0, root))
      else
        N-parse-failed
    )

  let parse tokens =
    let-mutable n <- 0 in
    let-rec take-while
      | fn a [] = (a, [])
      | fn a (x :: xs) = (
        if (fn x) then (take-while fn (List.concat [a; [x]]) xs)
        else (a, (x :: xs))
      )
    in
    let-rec inner
      | ((T-char(c)) :: []) = N-lit(c)
      | ((T-char(c)) :: rest) = N-cat(N-lit(c), (inner rest))
      | ((T-lparen) :: rest) = (
        let (subpat, rest) = take-while (fun x -> (
          match x with
          | T-rparen -> false
          | _ -> true
        )) [] rest in
        match rest with
        | ((T-rparen) :: []) -> (
          let () = n <- !n + 1 in
          N-paren(!n, (inner subpat))
        )
        | ((T-rparen) :: rest) -> (
          let () = n <- !n + 1 in
          N-cat(N-paren(!n, (inner subpat)), (inner rest))
        )
      )
      | [] = N-empty
    in
    let root = inner tokens in
    N-cat(N-ng-star(N-dot), N-paren(0, root))

  let inspect-ast root =
    let-rec inner a n =
      match n with
      | N-cat(t1, t2) -> a ^ `N-cat(` ^ (inner ` ` t1) ^ `, ` ^ (inner ` ` t2) ^ `)`
      | N-dot -> a ^ `N-dot`
      | N-empty -> a ^ `N-empty`
      | N-lit(c) -> a ^ `N-lit(` ^ c ^ `)`
      | N-ng-star(t) -> a ^ `N-ng-star(` ^ (inner ` ` t) ^ `)`
      | N-paren(n, t) -> a ^ `N-paren(` ^ (arabic n) ^ `,` ^ (inner ` ` t) ^ `)`
    in
    inner ` ` root

  let compile ast =
    let-rec inner t bytecodes =
      match t with
      | N-cat(l, r) -> List.concat [bytecodes; (inner l []); (inner r [])]
      | N-dot -> List.append bytecodes [O-any]
      | N-empty -> List.append bytecodes []
      | N-lit(c) -> List.append bytecodes [O-char(c)]
      | N-ng-star(t) -> (
          let bs = (inner t []) in
          List.concat [bytecodes; [O-split(List.length(bs) + 2, 1)]; bs; [O-jump(-List.length(bs) - 1)]]
        )
      | N-paren(n, t) -> List.concat [bytecodes; [O-substart(n)]; (inner t []); [O-subend(n)]]
    in
    List.append (inner ast []) [O-match]

  let exec bytecodes str =
    let-rec set-sub-start
      | n cn [] = (n, cn, -1) :: []
      | n cn ((n2, s, e) :: xs) =
        if n == n2 then (n, cn, -1) :: xs
        else (n2, s, e) :: (set-sub-start n cn xs)
    in

    let-rec set-sub-end
      | n cn [] = (n, -1, cn) :: []
      | n cn ((n2, s, e) :: xs) =
        if n == n2 then ((n, s, cn) :: xs)
        else ((n2, s, e) :: (set-sub-end n cn xs))
    in

    let substring-assoc str assoc =
      assoc |> List.map (fun (n, s, e) -> (n, (string-sub str s (e - s))))
    in

    let-rec inner bytecodes bn cs cn assoc =
      let b = Option.from O-not-match (List.nth bn bytecodes) in
      match b with
      | O-any -> (
          if (List.length cs) <= cn then None
          else (inner bytecodes (bn + 1) cs (cn + 1) assoc)
        )
      | O-char(c) -> (
          match (List.nth cn cs) with
          | Some(c2) ->
            if (string-same c c2) then (inner bytecodes (bn + 1) cs (cn + 1) assoc)
            else None
          | None -> None
        )
      | O-jump(bn-offset) -> (inner bytecodes (bn + bn-offset) cs cn assoc)
      | O-match -> Some((substring-assoc str assoc))
      | O-not-match -> None
      | O-split(bn-offset1, bn-offset2) -> (
          match (inner bytecodes (bn + bn-offset1) cs cn assoc) with
          | None -> (inner bytecodes (bn + bn-offset2) cs cn assoc)
          | Some(x) -> Some(x)
          )
      | O-subend(n) -> (inner bytecodes (bn + 1) cs cn (set-sub-end n cn assoc))
      | O-substart(n) -> (inner bytecodes (bn + 1) cs cn (set-sub-start n cn assoc))
    in
    inner bytecodes 0 (split-into-chars str) 0 []

  let inspect-bytecodes bytecodes =
    let-rec inner a bs =
      match bs with
      | (O-any) :: rest -> inner (a ^ `O-any; `) rest
      | (O-char(c)) :: rest -> inner (a ^ `O-char(` ^ c ^ `); `) rest
      | (O-match) :: rest -> inner (a ^ `O-match; `) rest
      | (O-not-match) :: rest -> inner (a ^ `O-not-match; `) rest
      | (O-jump(n)) :: rest -> inner (a ^ `O-jump(` ^ (arabic n) ^ `); `) rest
      | (O-split(n, m)) :: rest -> inner (a ^ `O-split(` ^ (arabic n) ^ `, ` ^ (arabic m) ^ `); `) rest
      | (O-subend(m)) :: rest -> inner (a ^ `O-subend(` ^ (arabic m) ^ `); `) rest
      | (O-substart(n)) :: rest -> inner (a ^ `O-substart(` ^ (arabic n) ^ `); `) rest
      | [] -> a
    in
    inner ` ` bytecodes

  let from r =
    let tokens = lex r in
    % let root = parse tokens in
    % let bytecodes = compile root in
    % (fun s2 -> (
    %   % Some([(0, (inspect-bytecodes bytecodes))])
    %   (exec bytecodes s2)
    % ))
    let root2 = parse2 tokens in
    let bytecodes2 = compile root2 in
    (fun s2 -> (
      % Some([(0, (inspect-ast root2))])
      % Some([(0, (inspect-bytecodes bytecodes2))])
      (exec bytecodes2 s2)
    ))
end
